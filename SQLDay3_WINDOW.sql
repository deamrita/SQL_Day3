SELECT * FROM STUDENT_DET
SELECT * FROM COURSE

----------TO DISPLAY THE HIGHEST_SCORER STUDENT NAME UNDER EACH COURSE NAME ----------------------
-----------FIRST_VALUE()---------------------------
SELECT S.*, C.COURSE_NAME,
FIRST_VALUE(S.STU_NAME) OVER (PARTITION BY C.COURSE_NAME ORDER BY S.STUDENT_SCORE DESC) AS HIGHEST_SCORER 
FROM STUDENT_DET S 
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID

----------TO DISPLAY THE LOWEST_SCORER STUDENT NAME UNDER EACH COURSE NAME ----------------------
-----------LAST_VALUE()---------------------------
SELECT S.*, C.COURSE_NAME,
LAST_VALUE(S.STU_NAME) OVER(PARTITION BY C.COURSE_NAME ORDER BY S.STUDENT_SCORE DESC) AS  LOWEST_SCORER
FROM STUDENT_DET S 
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID
----ABOVE QUERY WILL NOT GIVE YOU THE RESULT EXPECTED BY YOU DUE TO DEFAULT FRAME CLAUSE---------------
----FRAME A SUBSET OF PARTITION----------------
------DEFAULT FRAME CLAUSE AFTER ORDER BY IS : RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW---------
------NEED TO CHANGE THE DEFAULT FRAME CLAUSE-----------------------
SELECT S.*, C.COURSE_NAME,
LAST_VALUE(S.STU_NAME) 
OVER(PARTITION BY C.COURSE_NAME ORDER BY S.STUDENT_SCORE DESC RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS  LOWEST_SCORER
FROM STUDENT_DET S 
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID
-----------CAN GET SAME TYPE RESULT BY USING FIRST_VALUE() JUST BY REMOVING DESC---------------
------------READ DIFFERENCE BETWEEN ROWS AND RANGE FOR DUPLICATE VALUE-----------------------


---------OPTMIZING THE CODE OF WINDOW FUNCTION----------------
--------???NOT SURE WHY NOT WORKING???--------------
SELECT S.*, C.COURSE_NAME,
RANK() OVER W AS RNK,
DENSE_RANK() OVER W AS DNS_RNK
FROM STUDENT_DET S
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID
WINDOW W AS (PARTITION BY C.COURSE_NAME ORDER BY S.STUDENT_SCORE DESC)

-----NTH VALUE---------------------
----------TO DISPLAY THE 2ND HIGHEST_SCORER STUDENT NAME UNDER EACH COURSE NAME ----------------------
------NTH_VALUE() ONLY FOR ORACLE--------------------
SELECT S.*, C.COURSE_NAME,
NTH_VALUE(S.STU_NAME,2) OVER(PARTITION BY C.COURSE_NAME ORDER BY S.STUDENT_SCORE DESC RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
FROM STUDENT_DET S 
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID

----NTILE--------------
--------------TO SEGREGATE TOP SCORER MID LEVEL SCORER AND BOTTOM LEVEL SCORER AMONG ALL STUDENT---------------

SELECT X.STU_NAME,X.STUDENT_SCORE,
CASE WHEN X.BUCKETS = 1 THEN 'TOP SCORER'
     WHEN X.BUCKETS = 2 THEN 'MID SCORER'
	 WHEN X.BUCKETS = 3 THEN 'BOTTOM SCORER' END REMARKS
FROM
(SELECT S.*,C.COURSE_NAME,
NTILE(3) OVER(ORDER BY S.STUDENT_SCORE DESC) AS BUCKETS -- AS 3 BUCKETS (TOP MID BOTTOM)
FROM STUDENT_DET S
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID) X

----CUME_DIST (CUMULATIVE DISTRIBUTION)
--- VALUE BW 0 AND 1
---CURRENT ROW NO/TOTAL NO OF ROWS

SELECT S.*,C.COURSE_NAME,
CUME_DIST() OVER(ORDER BY S.STUDENT_SCORE DESC) CUME_DISTRIBUTION
FROM 
STUDENT_DET S INNER JOIN
COURSE C
ON S.COURSE_ID = C.COURSE_ID
----------ALL THE STUDENT WHO ARE ON FIRST 30% BASED ON SCORE------------
SELECT * FROM
(SELECT S.*,C.COURSE_NAME,
CUME_DIST() OVER(ORDER BY S.STUDENT_SCORE DESC) CUME_DISTRIBUTION
FROM 
STUDENT_DET S INNER JOIN
COURSE C
ON S.COURSE_ID = C.COURSE_ID) X
WHERE X.CUME_DISTRIBUTION <= 0.3

------ PERCENT_RANK---------------
----VALUE 0 TO 1
---HOW MUCH PERCENTAGE MORE 'hjt' SCORED WHEN COMPARED TO ALL STUDENTS
---CURRENT ROW NO -1 /TOTAL NO OF ROWS -1

SELECT S.*,C.COURSE_NAME,
PERCENT_RANK() OVER(ORDER BY S.STUDENT_SCORE) AS PERCENT_RANK
FROM
STUDENT_DET S
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID
WHERE S.STU_NAME = 'hjt'

------------------DISPLAY 2ND TOP SCORER FROM EACH COURSE-----------
SELECT * 
FROM
(SELECT S.*, C.COURSE_NAME,
DENSE_RANK() OVER(PARTITION BY C.COURSE_NAME ORDER BY S.STUDENT_SCORE DESC) RANK
FROM
STUDENT_DET S
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID) X
WHERE X.RANK = 2

SELECT * 
FROM
(SELECT S.*, C.COURSE_NAME,
DENSE_RANK() OVER(ORDER BY S.STUDENT_SCORE DESC) RANK
FROM
STUDENT_DET S
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID) X
WHERE X.RANK = 2

SELECT *
FROM
STUDENT_DET S
INNER JOIN COURSE C
ON S.COURSE_ID = C.COURSE_ID



